# SDD - Spacial Driven Design: Conceito de Desenvolvimento Orientado a Espaço

A programação estruturada por muito tempo foi comumente utilizada na criação de novos sistemas. O sistema era dividido em blocos de código, funções atômicas que se dividiam em três passos: entrada, processamento e saída. Com o crescimento da complexidade dos sistemas, este paradigma tornou-se limitante para a expansão das funcionalidades, criando uma confusão na hora de mexer na estrutura. 

Com esse grande problema, as empresas que produziam software necessitavam criar uma nova metodologia que solucionasse os problemas do paradigma estruturado. Foi quando surgiu o Paradigma Orientado a Objetos (POO), com o intuito de dividir o sistema em partes de forma que fosse facilmente mantível, podendo por conveniência também serem reutilizáveis. Mas qual seria o centro desse paradigma? A menor partícula abstrata da realidade: o objeto. O objeto pode ser qualquer coisa, desde um átomo, até uma pessoa, onde um conjunto de átomos formam moléculas, que se formam tecidos, organismos e finalmente um sistema, que no caso, pode ser representado como o cérebro humano. Um periférico extremamente eficiente capaz de alcançar as mais diversas façanhas.

Com esse modelo em mente, o mercado iniciou a produção de novos sistemas, utilizando este tão inovador e eficiente paradigma. Muitos sistemas foram sendo criados, com necessidades de mudanças, e quanto maiores os sistemas, mais acoplados e mais difíceis de serem mantidos, embora dessa vez, o conceito de orientação a objetivos estivesse sendo seguido. Mas ora, por qual motivo o paradigma que foi criado para resolver todos os problemas chegara ao mesmo ponto falho de antes: a ineficiência de manter o sistema enquanto ele cresce?

E mais uma vez, outras façanhas foram sendo criadas pelos homens com intuito de ingenuamente encontrar uma solução ótima: a divisão de novas camadas! E aí vem aquela sigla tão conhecida no mundo da computação: o MVC. O conceito de POO e a arquitetura MVC tomou todas as empresas, academias e a mente de jovens entusiastas de tecnologia sedentos por um modelo que atenda a todos os cenários.Independente do tamanho do sistema, o padrão MVC viera para salvá-los.

Com o crescimento da capacidade computacional, dispositivos menores comportaram cada vez mais processamento, possibilitando o suporte ao crescimento dos sistemas. Elevando o nível das aplicações e consequentemente aumentando o código, surgindo assim os monolitos. Estruturas infladas com crescimento vertical. Se precisar de uma nova feature, as camadas serão engordadas para comportar a modificação. E sempre desta forma, correndo sempre atrás do próprio rabo, mas agora a onda da vez é o micro-serviço.

Eu conto ou vocês contam? Não preciso repetir a história para saber qual será o futuro, não é? Mas a pergunta que fica é: no que estamos errando?

E aqui está a resposta: queremos ser como o universo, mas não respeitamos as suas leis! Isso mesmo que você acabou de ler, Einstein estaria com os olhos esbugalhados nesse momento. Vou dar mais uma dica: se queremos tornar a computação um espelho do universo, devemos ser exatamente como o universo é. Chega de mais delongas. Já sabemos que dois corpos não ocupam o mesmo espaço. Mas já pararam para pensar que um corpo também não ocupa dois espaços diferentes?

Deixa eu explicar melhor, mas para isso, preciso desmistificar um conceito que foi enraizado na sua cabeça: a reutilização de código! Muitos alunos aprendem nas academias, eu fui um deles, que um sistema de qualidade é um sistema com baixo acoplamento, alta coesão e com boas práticas de reutilização de código. Que um sistema precisa ser fracamente acoplado, disso eu não tenho dúvidas, ora, quanto mais atômico, menos relacionamentos possuir, mais fácil de manter. Existe algo mais fácil de manter do que um bloco de função que possui entradas e saídas bem definidas? E que eu um sistema precisa ser coeso também concordo. Existe algo mais coeso do que uma instrução de código? Imagina se todo sistema resumisse a complexidade de uma função, seria maravilhoso. E a reutilização? Este tão sonhado conceito que queremos atender, onde se encaixa? Como reutilizar um bloco de código em diferentes lugares e ainda sim manter o sistema fracamente acoplado? São tantos serviços que reutilizam aquele bloco de código, que se eu mexer em um ponto e vírgula é capaz do monolito se partir ao meio. Quase como um buraco negro que atrai todas os corpos, fazendo com que as estruturas sejam escravas rodeando eternamente a sua órbita.

Você deve estar pensando: "Então não devo reutilizar código? Não consigo nem imaginar um exemplo que eu possa utilizar esse conceito. Como ficará a divisão de camadas e estrutura de pastas?". Sim, minha cabeça também explodiu quando cheguei nesse ponto do raciocínio, mas não se preocupe, eu tenho a resposta para todas as suas dúvidas. Mas adiantando, vou te dar um tempo para pensar em me responder uma pergunta: Concorda que o universo é a coisa mais perfeita que existe? Uma junção de leis físicas que não falham. Podemos dizer que o universo é o software mais bem projetado do mundo rsrs. E nesse tão lindo sistema que possui uma complexidade infinita, e que ao mesmo tempo não possui um único bug, eu te pergunto: em que parte dessa construção divina você enxerga reuso?

Exatamente isso que você leu, no universo não existe reuso. Se Deus, o melhor programador do mundo não focou em reuso, você acha que você um mero mortal vai conseguir alcançar a reutilização e ainda sim construir um sistema perfeito e sem bugs? Acredito que não, em? Então, vamos parar de preguiça e vamos encarar cada componente como único, do jeitinho que Deus fez.

Brincadeiras a parte, embora eu seja ateu, isso é divertido. Isso vai contra tudo o que aprendemos até hoje, mas vamos abrir um pouco a cabeça, sair do estado de negação e viajar um pouquinho, só assim você enxergará a luz ao final do túnel. Tá, agora voltemos à imaginação. Como criar um sistema sem reutilizar código? Sendo assim, preciso ter blocos de códigos repetidos em diferentes lugares? A resposta é Sim. Mas veja o lado positivo, não é porque é software que precisa ser 100% a cópia do universo. Podemos burlar um pouquinho as coisas. No universo, tirando a impressora 3D, ainda não existe controle de versão como o GIT, onde eu possa fabricar objetos físicos dentro do meu próprio sistema, se bem que a impressora 3D faz isso rsrs. Pronto, o GIT será a nossa impressora 3D para este exemplo. 

Imagina que temos um sistema com diferentes páginas e diferentes componentes reutilizáveis por toda a aplicação. Neste novo conceito, cada página utilizará os mesmos botões sendo consolidados aos moldes do template previamente criado de botão. Para facilitar o processo, o botão pode ser um repositório do GIT, onde para cada lugar utilizado no código, ele tenha a sua cópia física. 

E se uma página precisa modificar o botão? Daí vai o negócio decidir, esse botão modificado vai estar presente em todas as outras páginas do sistema? Se sim, você precisará sair modificando o botão em todas as páginas. Custoso, não é? Mas trazemos um exemplo real. Se a Apple vende um lote de iPhones com recursos físicos que precisam ser modificados, como faríamos? Você pensou em recall, não é? Se sim, acertou. Nenhuma empresa possui um método de ajuste físico simultâneo, até mesmo porque isso vai contra as leis da natureza. E porquê que no software precisa ser diferente?

Ferramentas podem ser desenvolvidas para facilitar o trabalho, conforme falado anteriormente, existe o conceito de submodules do git, onde você baixa o projeto e referencia na estrutura pai o commit respectivo do submódulo. Se ele precisa mudar para atender aos requisitos daquela página, então deverá modificar apenas naquela página, criando assim um novo estado daquele componente dentro daquele domínio.

Dessa forma, vamos começar a entender que o sistema de fato se tornará imutável, não necessitando de modificação, apenas de extensões, e assim a única preocupação que a empresa terá será a infraestrutura. Que trazendo para a imaginação, é o que separa o software do mundo físico. É o limite entre os dois mundos.

Eis que surge o novo conceito de desenvolvimento de software, o SDD - Spacial Drive Design (Desenvolvimento Orientado a Espaço) onde encaramos o desenvolvimento de software como a criação de um objeto real, presente unicamente em uma fatia do espaço, atendendo as principais leis da física que compõem o universo. Dessa forma, traremos a solução para o paradigma físico, conseguindo expandir a solução de software proporcional a necessidade de hardware. A programação OO estava correta em tudo, porém, pela conveniência humana de não conseguir conviver com códigos duplicados, criou uma estrutura de prédio de cartas onde as indústrias de superbonder ganharam e ganham muito dinheiro dando cursos de como criar uma estrutura sólida e de qualidade para a sua empresa.

Não entendeu? Vou te explicar melhor. Sabemos que cada arquivo possui um número de bytes, que por sua vez está inserido dentro das seções do nosso disco rígido. Este disco rígido é formado pela matéria, portanto, possui o seu espaço no universo. Logo, podemos dizer que a classe de software possui a sua representatividade também no mundo real.

Não existe problema em criarmos múltiplas instâncias de uma classe, afinal, como falado anteriormente, no mundo real existem as impressoras, que por meio de um molde (classe), conseguiria criar milhares de objetos (instâncias) enquanto tivermos tinta para isso. E se modificamos um objeto, concorda que essa modificação vai surtir efeito apenas nele e não nos demais? Quando criamos um arquivo de classe e queremos que ele seja onipresente, estamos dizendo que um único corpo ocupa diferentes lugares do espaço, sendo extramemente densa, podendo encarar como o nosso buraco negro rsrs. Stephen Hawking deve estar se revirando nesse momento.
Pra ficar mais fácil de entender, vamos ilustrar. Imagina que estamos construindo um aplicativo que lista produtos de uma loja Em uma estrutura e2e, ficaria mais um menos assim: 




Agora imagina que eu quero poder favoritar um determinado produto, criando assim uma lista de produtos favoritados por mim. Como ficaria a estrutura? Poderíamos adicionar um botão no CardapioPage, adicionar um método de favoritar no ProdutoResource, e em seguida criar novas API’s na API Produto, criando também uma nova tabela de favoritos com os id do produto e da classe Pessoa no banco de dados. Isso seria errado? A princípio não se você quer criar um monolito.



E assim, para todos os novas features, algumas classes vão inflando a ponto de serem o Core do sistema, onde todos as features dependem daquele módulo em específico. Mas como seria o modelo ideal para esse exemplo? Este:



Espacialmente, as páginas possuem botões, botões por sua vez se comunicam com seus respectivos controllers, os controllers chamam os resources, que chamam os endpoints que se conectam ao banco de dados. Mas por qual motivo a informação de favoritos não está contida no objeto produto? A resposta é simples!

Imagina que ao invés de estar utilizando o celular para visualizar os itens, agora você acordou de um teletransporte no meio de um corredor dentro de um supermercado. Você olha para os produtos e tenta imaginar quais são os seus produtos favoritos. Imaginou? Concorda comigo que essa informação só existe dentro de você e em nenhum lugar a mais? Se você quisesse saber quais são os produtos favoritos de todos que frequentam o supermercado, como você faria? Essa informação só seria possível extrair se reunissemos todas as pessoas que passaram por ali. No software não é diferente. Esta informação está na contida em cada indivíduo, mas reunir a todos levaria muito tempo, além do esforço 
gasto para isso. 

E se colocássemos um funcionário para coletar para cada produto, todos os clientes que saíram pela porta que favoritariam aquele item, registrando essas informações em um caderno de anotações, conseguiríamos reunir quais itens estão sendo mais favoritados? A resposta é sim, pois agora a informação está presente no seu devido espaço no universo. Eis que tá a “redundância de informação”. No universo, a redundância é crucial para o equilíbrio. Não a redundância de matéria, mas a redundância de formas. Veja uma esfera, ela pode ser utilizada em diferentes contextos, seja em um jogo de bolas de gude, uma partida de futebol, como o formato das gotas, mas não quer dizer que elas desempenham a mesma função no universo, ou estão presentes em mais de um espaço ao mesmo tempo.

E é nesse exato momento que separamos a genialidade de Deus da ignorância de nós humanos, tentando criar algo perfeito, sem tentar entender que o perfeito já existe, que é o universo. E não existe universo sem a singularidade do espaço ou do átomo. Portanto, o concluo que o desenvolvimento de software deve seguir o domínio espacial, respeitando a todas as regras da física caso a gente queira construir software de qualidade.
